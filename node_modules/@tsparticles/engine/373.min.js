/*! For license information please see 373.min.js.LICENSE.txt */
(this.webpackChunk_tsparticles_engine=this.webpackChunk_tsparticles_engine||[]).push([[373],{2373:(t,i,e)=>{e.d(i,{Particle:()=>f});var s=e(5410),o=e(3635),a=e(8279),n=e(5084),h=e(2418),r=e(7788),c=e(9087),l=e(3893);const p=.5;function d(t){if(!(0,a.dB)(t.outMode,t.checkModes))return;const i=2*t.radius;t.coord>t.maxCoord-i?t.setCb(-t.radius):t.coord<i&&t.setCb(t.radius)}class f{constructor(t,i){this.container=i,this._calcPosition=(t,i,e,a=0)=>{for(const[,o]of t.plugins){const t=void 0!==o.particlePosition?o.particlePosition(i,this):void 0;if(t)return s.U.create(t.x,t.y,e)}const n=t.canvas.size,h=(0,o.mC)({size:n,position:i}),r=s.U.create(h.x,h.y,e),c=this.getRadius(),l=this.options.move.outModes,p=i=>{d({outMode:i,checkModes:["bounce"],coord:r.x,maxCoord:t.canvas.size.width,setCb:t=>r.x+=t,radius:c})},f=i=>{d({outMode:i,checkModes:["bounce"],coord:r.y,maxCoord:t.canvas.size.height,setCb:t=>r.y+=t,radius:c})};if(p(l.left??l.default),p(l.right??l.default),f(l.top??l.default),f(l.bottom??l.default),this._checkOverlap(r,a)){const i=1;return this._calcPosition(t,void 0,e,a+i)}return r},this._calculateVelocity=()=>{const t=(0,o.lQ)(this.direction).copy(),i=this.options.move;if("inside"===i.direction||"outside"===i.direction)return t;const e=(0,o.Id)((0,o.Gu)(i.angle.value)),s=(0,o.Id)((0,o.Gu)(i.angle.offset)),a={left:s-e*p,right:s+e*p};return i.straight||(t.angle+=(0,o.vd)((0,o.Cs)(a.left,a.right))),i.random&&"number"==typeof i.speed&&(t.length*=(0,o.sZ)()),t},this._checkOverlap=(t,i=0)=>{const e=this.options.collisions,s=this.getRadius();if(!e.enable)return!1;const a=e.overlap;if(a.enable)return!1;const h=a.retries;if(h>=0&&i>h)throw new Error(`${n.gK} particle is overlapping and can't be placed`);return!!this.container.particles.find((i=>(0,o.Sp)(t,i.position)<s+i.getRadius()))},this._getRollColor=t=>{if(!t||!this.roll||!this.backColor&&!this.roll.alter)return t;const i=this.roll.horizontal&&this.roll.vertical?2:1,e=this.roll.horizontal?Math.PI*p:0;return Math.floor(((this.roll.angle??0)+e)/(Math.PI/i))%2?this.backColor?this.backColor:this.roll.alter?(0,c.PL)(t,this.roll.alter.type,this.roll.alter.value):t:t},this._initPosition=t=>{const i=this.container,e=(0,o.Gu)(this.options.zIndex.value);this.position=this._calcPosition(i,t,(0,o.uZ)(e,0,i.zLayers)),this.initialPosition=this.position.copy();const n=i.canvas.size;switch(this.moveCenter={...(0,a.bt)(this.options.move.center,n),radius:this.options.move.center.radius??0,mode:this.options.move.center.mode??"percent"},this.direction=(0,o.Gk)(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside"}this.offset=s.O.origin},this._engine=t}destroy(t){if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;const i=this.container,e=this.pathGenerator,s=i.shapeDrawers.get(this.shape);s?.particleDestroy?.(this);for(const[,e]of i.plugins)e.particleDestroyed?.(this,t);for(const e of i.particles.updaters)e.particleDestroyed?.(this,t);e?.reset(this),this._engine.dispatchEvent("particleDestroyed",{container:this.container,data:{particle:this}})}async draw(t){const i=this.container,e=i.canvas;for(const[,s]of i.plugins)await e.drawParticlePlugin(s,this,t);await e.drawParticle(this,t)}getFillColor(){return this._getRollColor(this.bubble.color??(0,h.gW)(this.color))}getMass(){return this.getRadius()**2*Math.PI*p}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??(0,h.gW)(this.strokeColor))}async init(t,i,e,s){const c=this.container,p=this._engine;this.id=t,this.group=s,this.effectClose=!0,this.effectFill=!0,this.shapeClose=!0,this.shapeFill=!0,this.pathRotation=!1,this.lastPathTime=0,this.destroyed=!1,this.unbreakable=!1,this.rotation=0,this.misplaced=!1,this.retina={maxDistance:{}},this.outType="normal",this.ignoresResizeRatio=!0;const d=c.retina.pixelRatio,f=c.actualOptions,u=(0,l.x)(this._engine,c,f.particles),g=u.effect.type,y=u.shape.type,{reduceDuplicates:v}=u;this.effect=(0,a.wA)(g,this.id,v),this.shape=(0,a.wA)(y,this.id,v);const w=u.effect,b=u.shape;if(e){if(e.effect?.type){const t=e.effect.type,i=(0,a.wA)(t,this.id,v);i&&(this.effect=i,w.load(e.effect))}if(e.shape?.type){const t=e.shape.type,i=(0,a.wA)(t,this.id,v);i&&(this.shape=i,b.load(e.shape))}}this.effectData=function(t,i,e,s){const o=i.options[t];if(o)return(0,a.ZB)({close:i.close,fill:i.fill},(0,a.wA)(o,e,s))}(this.effect,w,this.id,v),this.shapeData=function(t,i,e,s){const o=i.options[t];if(o)return(0,a.ZB)({close:i.close,fill:i.fill},(0,a.wA)(o,e,s))}(this.shape,b,this.id,v),u.load(e);const C=this.effectData;C&&u.load(C.particles);const m=this.shapeData;m&&u.load(m.particles);const _=new r.o(p,c);_.load(c.actualOptions.interactivity),_.load(u.interactivity),this.interactivity=_,this.effectFill=C?.fill??u.effect.fill,this.effectClose=C?.close??u.effect.close,this.shapeFill=m?.fill??u.shape.fill,this.shapeClose=m?.close??u.shape.close,this.options=u;const P=this.options.move.path;this.pathDelay=(0,o.Gu)(P.delay.value)*n.X5,P.generator&&(this.pathGenerator=this._engine.getPathGenerator(P.generator),this.pathGenerator&&c.addPath(P.generator,this.pathGenerator)&&await this.pathGenerator.init(c)),c.retina.initParticle(this),this.size=(0,a.V0)(this.options.size,d),this.bubble={inRange:!1},this.slow={inRange:!1,factor:1},this._initPosition(i),this.initialVelocity=this._calculateVelocity(),this.velocity=this.initialVelocity.copy();this.moveDecay=1-(0,o.Gu)(this.options.move.decay);const z=c.particles;z.setLastZIndex(this.position.z),this.zIndexFactor=this.position.z/c.zLayers,this.sides=24;let D=c.effectDrawers.get(this.effect);D||(D=this._engine.getEffectDrawer(this.effect),D&&c.effectDrawers.set(this.effect,D)),D?.loadEffect&&await D.loadEffect(this);let k=c.shapeDrawers.get(this.shape);k||(k=this._engine.getShapeDrawer(this.shape),k&&c.shapeDrawers.set(this.shape,k)),k?.loadShape&&await k.loadShape(this);const x=k?.getSidesCount;x&&(this.sides=x(this)),this.spawning=!1,this.shadowColor=(0,h.tX)(this.options.shadow.color);for(const t of z.updaters)await t.init(this);for(const t of z.movers)await(t.init?.(this));await(D?.particleInit?.(c,this)),await(k?.particleInit?.(c,this));for(const[,t]of c.plugins)t.particleCreated?.(this)}isInsideCanvas(){const t=this.getRadius(),i=this.container.canvas.size,e=this.position;return e.x>=-t&&e.y>=-t&&e.y<=i.height+t&&e.x<=i.width+t}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){for(const t of this.container.particles.updaters)t.reset?.(this)}}}}]);